{
  
    
        "post0": {
            "title": "Portfolio Optimization",
            "content": "Problem Statement . The expected return and standard deviation of stock 1 are 4% and 3%, respectively. For stock 2, the expected return and standard deviation are 2% and 2%, respectively. For stock 3, the expected return and standard deviation are 1% and 1.5%, respectively. Suppose the correlation between stocks 1 and 2 is 0.2, between stocks 1 and 3 0.4, and between stocks 2 and 3 0.1. . Model Formulation . Sets &amp; Indices . $i ∈ text{stock} = {1,2,3 }$: set of stocks . Parameters . $ mu_i ∈ mathbb{R}^+$: expected return of stock $i$ . $ sigma_i ∈ mathbb{R}^+$: standard deviation of stock $i$ . $b ∈ mathbb{R}^+$: the minimum required expected return for the portfolio. . Decision Variables . $x_i$: n-element vector where each element represents the fraction of the porfolio to invest in each stock | . Objective Function . begin{equation} text{Minimize} sum_{i=1}^{n} sum_{j=1}^{n} mu_i mu_j sigma_{ij} tag{0} end{equation}Constraints . minimum expected return | . begin{equation} sum_{i=1}^{n} mu_i x_i geq b tag{1} end{equation} total investment | . begin{equation} sum_{i=1}^{n} x_i = 1 tag{2} end{equation} not short-selling | . begin{equation} x_i geq 0 quad forall i in text{stock} tag{3} end{equation} 1) Minimum return . Find the portfolio with the lowest risk, among those with an expected return of at least 2% . %pip install gurobipy . Collecting gurobipy Downloading gurobipy-9.5.1-cp37-cp37m-manylinux2014_x86_64.whl (11.5 MB) |████████████████████████████████| 11.5 MB 4.4 MB/s Installing collected packages: gurobipy Successfully installed gurobipy-9.5.1 . import gurobipy as gu . n = 3 #number of stocks ExpectedReturn = [0.04, 0.02, 0.01] #vector of expected returns with length n Covariance = [[0.03, 0.00012, 0.00018], [0.00012, 0.02, 0.00003], [0.00018, 0.00003, 0.015]] #covariance matrix with dimension nxn MinReturn = 0.02 . m = gu.Model(&quot;Portfolio Optimization 1&quot;) . Restricted license - for non-production use only - expires 2023-10-25 . StockWeight = m.addVars(n, name = &#39;StockWeight&#39;, lb = 0.0, vtype=gu.GRB.CONTINUOUS) . m.setObjective(sum(sum(StockWeight[i]*StockWeight[j]*Covariance[i][j] for i in range(n)) for j in range(n)), gu.GRB.MINIMIZE) . m.addConstr(sum(StockWeight[i] for i in range(n)) == 1, name = &#39;SumofWeights&#39;) m.addConstr(sum(StockWeight[i]*ExpectedReturn[i] for i in range(n)) &gt;= MinReturn, name = &#39;ConstraintonMinReturn&#39;) . &lt;gurobi.Constr *Awaiting Model Update*&gt; . m.optimize() . Gurobi Optimizer version 9.5.1 build v9.5.1rc2 (linux64) Thread count: 1 physical cores, 2 logical processors, using up to 2 threads Optimize a model with 2 rows, 3 columns and 6 nonzeros Model fingerprint: 0x390fa4c2 Model has 6 quadratic objective terms Coefficient statistics: Matrix range [1e-02, 1e+00] Objective range [0e+00, 0e+00] QObjective range [1e-04, 6e-02] Bounds range [0e+00, 0e+00] RHS range [2e-02, 1e+00] Presolve time: 0.02s Presolved: 2 rows, 3 columns, 6 nonzeros Presolved model has 6 quadratic objective terms Ordering time: 0.00s Barrier statistics: Free vars : 2 AA&#39; NZ : 6.000e+00 Factor NZ : 1.000e+01 Factor Ops : 3.000e+01 (less than 1 second per iteration) Threads : 1 Objective Residual Iter Primal Dual Primal Dual Compl Time 0 3.20152377e+05 -3.20152377e+05 2.50e+03 2.47e-07 1.00e+06 0s 1 1.15177644e+04 -1.17907196e+04 1.97e+02 1.95e-08 8.42e+04 0s 2 4.34195814e-02 -3.58271785e+02 6.80e-01 6.72e-11 3.82e+02 0s 3 6.98591118e-03 -1.98336951e+02 6.80e-07 6.94e-17 4.96e+01 0s 4 6.98585719e-03 -1.92714187e-01 4.66e-12 0.00e+00 4.99e-02 0s 5 6.95633171e-03 5.66424294e-03 1.48e-14 0.00e+00 3.23e-04 0s 6 6.75813420e-03 6.68576945e-03 6.94e-17 6.94e-18 1.81e-05 0s 7 6.73329099e-03 6.72497295e-03 3.41e-15 2.74e-18 2.08e-06 0s 8 6.72958274e-03 6.72842709e-03 1.83e-14 1.25e-18 2.89e-07 0s 9 6.72896822e-03 6.72882136e-03 5.30e-14 6.94e-18 3.67e-08 0s 10 6.72886123e-03 6.72885109e-03 6.70e-14 2.74e-19 2.54e-09 0s 11 6.72885183e-03 6.72885180e-03 1.17e-13 6.94e-18 6.72e-12 0s Barrier solved model in 11 iterations and 0.05 seconds (0.00 work units) Optimal objective 6.72885183e-03 . var = m.getVars() for i in range(n): print(var[i].varName, var[i].x) . StockWeight[0] 0.221851545261853 StockWeight[1] 0.3344459277157383 StockWeight[2] 0.4437025270221763 . print(&#39;Objective function&#39;, m.objVal) . Objective function 0.00672885182871444 . 2) What if we cannot invest more than half of our money in stocks 1 and 2? . To answer part 2, we need to add a new constraint involving stocks’ 1 and 2 decision variables. . Parameters . $a ∈ mathbb{R}^+$: the maximum required investment for the stock 1 and 2. . Constraints . Maximum investment | . begin{equation} x_1 + x_2 = a tag{1} end{equation} MaxInvest = 0.5 . m.addConstr(StockWeight[0] + StockWeight[1] == MaxInvest, name = &#39;MaxInvest&#39;) . &lt;gurobi.Constr *Awaiting Model Update*&gt; . m.optimize() . Gurobi Optimizer version 9.5.1 build v9.5.1rc2 (linux64) Thread count: 1 physical cores, 2 logical processors, using up to 2 threads Optimize a model with 3 rows, 3 columns and 8 nonzeros Model fingerprint: 0xb98dfd3d Model has 6 quadratic objective terms Coefficient statistics: Matrix range [1e-02, 1e+00] Objective range [0e+00, 0e+00] QObjective range [1e-04, 6e-02] Bounds range [0e+00, 0e+00] RHS range [2e-02, 1e+00] Presolve time: 0.02s Presolved: 3 rows, 3 columns, 8 nonzeros Presolved model has 6 quadratic objective terms Ordering time: 0.00s Barrier statistics: Free vars : 2 AA&#39; NZ : 1.000e+01 Factor NZ : 1.500e+01 Factor Ops : 5.500e+01 (less than 1 second per iteration) Threads : 1 Objective Residual Iter Primal Dual Primal Dual Compl Time 0 3.20072058e+05 -3.20072058e+05 2.50e+03 6.01e-02 1.00e+06 0s 1 4.83954583e+03 -5.08987963e+03 2.54e+02 6.11e-03 1.05e+05 0s 2 3.32693448e-02 -3.05887397e+02 5.42e-01 1.30e-05 3.01e+02 0s 3 6.97658803e-03 -1.15906961e+02 5.42e-07 1.30e-11 2.90e+01 0s 4 6.97658263e-03 -1.09052744e-01 5.43e-13 1.35e-14 2.90e-02 0s 5 6.97397122e-03 6.75207038e-03 1.11e-15 1.04e-16 5.55e-05 0s 6 6.94299555e-03 6.94200376e-03 1.11e-16 6.94e-18 2.48e-07 0s 7 6.94250050e-03 6.94249950e-03 8.33e-16 6.94e-18 2.48e-10 0s Barrier solved model in 7 iterations and 0.05 seconds (0.00 work units) Optimal objective 6.94250050e-03 . var = m.getVars() for i in range(n): print(var[i].varName, var[i].x) . StockWeight[0] 0.25000009613332785 StockWeight[1] 0.24999990386667328 StockWeight[2] 0.5000000000000022 . print(&#39;Objective function&#39;, m.objVal) . Objective function 0.006942500495087108 .",
            "url": "https://themuahdibportfolio.github.io/Blog_Finance/investment%20strategy/portfolio%20optimization/financial%20modelling/markowitz%20portfolio%20selection/risk%20&%20return/quadratic%20programming/mathematical%20optimization/gurobi/python/2022/05/01/_05_02.html",
            "relUrl": "/investment%20strategy/portfolio%20optimization/financial%20modelling/markowitz%20portfolio%20selection/risk%20&%20return/quadratic%20programming/mathematical%20optimization/gurobi/python/2022/05/01/_05_02.html",
            "date": " • May 1, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Trading with Simple Moving Average",
            "content": "Moving average-oscillators . Stock price series are volative. . To smooth out such a volatile series, we apply the moving average (MA) rule. According to the MA rule, two MAs of the stock price (a long period and a short period average) generate buy and sell signals. Specifically, we buy (or sell) when the short period average rises above (or falls below) the long period one. . Brock, W., Lakonishok, J., &amp; Lebaron, B. (1992). Simple Technical Trading Rules and the Stochastic Properties of Stock Returns (Vol 47, bll 1731–1764). . Importing required package . import eikon as ek # the Eikon Python wrapper package import numpy as np # NumPy import pandas as pd # pandas import cufflinks as cf # Cufflinks import configparser as cp . Connecting to Eikon Data API . ek.set_app_key(&#39;d6afdaa2e0d046dd945d1857d822079a4704ceb6&#39;) . Retrieving End-of-Day data . As an example, we retrieve the end-of-the-day stock prices of Amazon.com from January the 1st, 2010 to December the 1st, 2021. . ric = &#39;AMZN.O&#39; . data = ek.get_timeseries(ric, fields = &#39;CLOSE&#39;, start_date=&#39;2010-01-01&#39;, end_date=&#39;2021-12-01&#39; ) . data.head() . AMZN.O CLOSE . Date . 2010-01-04 133.9 | . 2010-01-05 134.69 | . 2010-01-06 132.25 | . 2010-01-07 130.0 | . 2010-01-08 133.52 | . data.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; DatetimeIndex: 3000 entries, 2010-01-04 to 2021-12-01 Data columns (total 1 columns): # Column Non-Null Count Dtype -- -- 0 CLOSE 3000 non-null Float64 dtypes: Float64(1) memory usage: 49.8 KB . data.normalize().iplot(kind=&#39;lines&#39;) . . In the above cell, we visualize the stock price time-series of Amazon.com in US dollars. We can see that the price has grown 2600% over almost 10 years. . Deriving the SMA Values . We choose 42 days as the short period and 252 days as the long period. Luckly, pandas provides convenience methods to calculate rolling statistics, such as SMAs, in a standardized way. . SMA1 = 42 SMA2 = 252 . data[&#39;SMA1&#39;] = data[&#39;CLOSE&#39;].rolling(SMA1).mean() data[&#39;SMA2&#39;] = data[&#39;CLOSE&#39;].rolling(SMA2).mean() . data.dropna(inplace=True) . data.tail() . AMZN.O CLOSE SMA1 SMA2 . Date . 2021-11-24 3580.41 | 3409.934286 | 3320.637857 | . 2021-11-26 3504.56 | 3414.424762 | 3321.905675 | . 2021-11-29 3561.57 | 3420.625952 | 3323.358968 | . 2021-11-30 3507.07 | 3425.912381 | 3324.704325 | . 2021-12-01 3443.72 | 3429.732857 | 3325.591786 | . data.iplot() . . The purpose of the simple MA method has been accomplished as the time-series has been smoothed by both SMAs. Clearly, the long period MA is smoother than the short period one. . However, it is still quite unclear where buy (or sell) signals lay. . Strategy Visualization . As we stated above, the reasoning of SMA is to be long when the short period MA is above the long period one, and it is to be short in the other case. To better visualize such a strategy, we represent the long position by +1 and a short position by -1. . data[&#39;POSITIONS&#39;] = np.where(data[&#39;SMA1&#39;] &gt; data[&#39;SMA2&#39;], 1, -1) . data.iplot(secondary_y=&#39;POSITIONS&#39;) . . A vectorized backtest . Backtesting is used to simulate the past performance of a trading strategy. The generated profit are often compared against a benmark performance, e.g., annualized returns. Vectorized backtesting is a fast backtesting technique which is used in the explorative stage of strategy research. . Log-returns are particularly usefull. . $ text{r}_t = log( dfrac{p_t}{p_{t-1}}) = log(p_t)-log(p_{t-1})$ . Consider the log-returns of an asset over three days $t=(1, 2,3)$. To compute the total return of the asset over the period, we sum the log-returns: $r_1+r_2+r_3$ . $ = (log(p_3)-log(p_2))+(log(p_2)-log(p_1))+(log(p_1)-log(p_0))$ . $ = (log(p_3)-log(p_0))$ . $ = log( dfrac{p_3}{p_0})$ . The backtest of the strategy, i.e., calculating the returns of the strategy over the considered period, is equal to compute the comulative sum of log-returns, followed by the exponential function. . data[&#39;RETURNS&#39;] = np.log(data[&#39;CLOSE&#39;] / data[&#39;CLOSE&#39;].shift(1)) # log returns in vectorized fashion . data[&#39;RETURNS&#39;].head() . Date 2010-12-31 &lt;NA&gt; 2011-01-03 0.023174 2011-01-04 0.004279 2011-01-05 0.012942 2011-01-06 -0.008358 Name: RETURNS, dtype: Float64 . data.dropna(inplace=True) . data[&#39;RETURNS&#39;].iplot() . . data.head(2) . AMZN.O CLOSE SMA1 SMA2 POSITIONS RETURNS . Date . 2011-01-03 184.22 | 174.541429 | 139.341281 | 1 | 0.023174 | . 2011-01-04 185.01 | 174.935238 | 139.540963 | 1 | 0.004279 | . Calculating the return of the strategy . The next step is to derive the returns of the strategy, by mutliplying the positionings (shifted by one day to avoid a foresight bias) with the stock returns. A long position earns the stock return, a short position earns the negative value of the stock return. . data[&#39;strategy&#39;] = data[&#39;POSITIONS&#39;].shift(1) * data[&#39;RETURNS&#39;] . data.head(2) . AMZN.O CLOSE SMA1 SMA2 POSITIONS RETURNS strategy . Date . 2011-01-03 184.22 | 174.541429 | 139.341281 | 1 | 0.023174 | NaN | . 2011-01-04 185.01 | 174.935238 | 139.540963 | 1 | 0.004279 | 0.004279 | . data.dropna(inplace=True) . data = data.iloc[1: , :] . data.head(5) . AMZN.O CLOSE SMA1 SMA2 POSITIONS RETURNS strategy . Date . 2011-01-04 185.01 | 174.935238 | 139.540963 | 1 | 0.004279 | 0.004279 | . 2011-01-05 187.42 | 175.375476 | 139.759892 | 1 | 0.012942 | 0.012942 | . 2011-01-06 185.86 | 175.734762 | 139.981559 | 1 | -0.008358 | -0.008358 | . 2011-01-07 185.49 | 176.056190 | 140.187789 | 1 | -0.001993 | -0.001993 | . 2011-01-10 184.68 | 176.399286 | 140.403551 | 1 | -0.004376 | -0.004376 | . The final step is to add up the single resulting log returns over time and to apply the exponential functions to arrive at the performance of the strategy compared to the benchmark of a passive investment in the stock. . np.exp(data[[&#39;RETURNS&#39;, &#39;strategy&#39;]].sum()) . AMZN.O RETURNS 18.693519 strategy 3.689030 dtype: float64 . data[[&#39;RETURNS&#39;, &#39;strategy&#39;]].cumsum().iplot() . . The performance of the strategy can also be compared over time to the benchmark investment. .",
            "url": "https://themuahdibportfolio.github.io/Blog_Finance/trading%20strategy/moving%20average%20oscillators/eikon%20data%20api/refinitiv%20product/simple%20moving%20average/visualization/vectorized%20backtesting/2022/05/01/_03_03_SMA.html",
            "relUrl": "/trading%20strategy/moving%20average%20oscillators/eikon%20data%20api/refinitiv%20product/simple%20moving%20average/visualization/vectorized%20backtesting/2022/05/01/_03_03_SMA.html",
            "date": " • May 1, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Edoardo is a master’s student at Copenhagen Business School. His major is in Applied Economics and Finance, whereas his minor is in data science. .",
          "url": "https://themuahdibportfolio.github.io/Blog_Finance/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://themuahdibportfolio.github.io/Blog_Finance/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}